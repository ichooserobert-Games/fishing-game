<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Kid Fishing (iPhone)</title>
<style>
  html, body { margin:0; padding:0; height:100%; background:#06101c; overflow:hidden;
    font-family:-apple-system, system-ui, Arial; color:#e8eefc; }
  canvas { display:block; width:100vw; height:100vh; touch-action:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>

<script>
(() => {
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const state = {
    w: 0, h: 0, t: 0, last: performance.now(),
    score: 0, best: 0,
    phase: "cast", // cast -> wait -> bite -> reel -> catch
    message: "Tap to CAST",
    msgT: 0,

    // Rod + line
    rodX: 0, rodY: 0,
    bobX: 0, bobY: 0,
    bobVX: 0, bobVY: 0,
    lineLen: 0,
    castPower: 0,
    aiming: false,

    // Bite meter
    meter: 0.5, meterV: 0.0,
    meterTarget: 0.5,
    biteNow: false,
    biteTimer: 0,

    // Fish
    fishes: [],
    caughtFish: null,

    // Particles
    bubbles: [],
    splashes: [],

    // Touch
    touchX: 0, touchY: 0,
    touching: false,

    // UI safe areas
    insetTop: 0,
    insetBottom: 0,
  };

  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function rand(a,b){ return a + Math.random()*(b-a); }

  function resize(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    state.w = Math.floor(innerWidth);
    state.h = Math.floor(innerHeight);
    canvas.width  = Math.floor(state.w * dpr);
    canvas.height = Math.floor(state.h * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);

    // Approx safe area padding on iPhone (good enough without CSS env vars)
    state.insetTop = 14;
    state.insetBottom = 18;

    resetRod();
  }
  addEventListener("resize", resize, {passive:true});

  function resetRod(){
    const w = state.w, h = state.h;
    state.rodX = w * 0.16;
    state.rodY = h * 0.22;
    state.bobX = state.rodX + 40;
    state.bobY = h * 0.40;
    state.bobVX = 0; state.bobVY = 0;
    state.lineLen = 180;
  }

  // Pretty background
  function drawBackground(){
    const {w,h,t} = state;
    const horizon = h*0.36;

    // Sky gradient
    const sky = ctx.createLinearGradient(0,0,0,horizon);
    sky.addColorStop(0, "#0b2a4a");
    sky.addColorStop(1, "#1b5a86");
    ctx.fillStyle = sky;
    ctx.fillRect(0,0,w,horizon);

    // Sun
    const sunX = w*0.78, sunY = horizon*0.42;
    const glow = ctx.createRadialGradient(sunX,sunY, 4, sunX,sunY, 120);
    glow.addColorStop(0, "rgba(255,240,200,0.95)");
    glow.addColorStop(0.35, "rgba(255,200,120,0.35)");
    glow.addColorStop(1, "rgba(255,200,120,0)");
    ctx.fillStyle = glow;
    ctx.beginPath(); ctx.arc(sunX,sunY,120,0,Math.PI*2); ctx.fill();

    // Clouds (simple soft blobs)
    function cloud(cx, cy, s){
      ctx.fillStyle = "rgba(255,255,255,0.18)";
      ctx.beginPath();
      ctx.ellipse(cx,cy, 52*s, 26*s, 0, 0, Math.PI*2);
      ctx.ellipse(cx+44*s,cy+4*s, 44*s, 22*s, 0, 0, Math.PI*2);
      ctx.ellipse(cx-44*s,cy+6*s, 40*s, 20*s, 0, 0, Math.PI*2);
      ctx.fill();
    }
    cloud(w*0.18 + Math.sin(t*0.08)*8, horizon*0.22, 1.0);
    cloud(w*0.42 + Math.sin(t*0.06)*10, horizon*0.14, 0.9);
    cloud(w*0.60 + Math.sin(t*0.05)*12, horizon*0.26, 1.1);

    // Distant hills
    ctx.fillStyle = "#0a2a2a";
    ctx.beginPath();
    ctx.moveTo(0, horizon);
    for(let x=0; x<=w; x+=40){
      const y = horizon - 18 + Math.sin((x*0.01)+(t*0.08))*8;
      ctx.lineTo(x, y);
    }
    ctx.lineTo(w, horizon);
    ctx.closePath();
    ctx.fill();

    // Water
    const waterTop = horizon;
    const water = ctx.createLinearGradient(0, waterTop, 0, h);
    water.addColorStop(0, "#07314c");
    water.addColorStop(1, "#021018");
    ctx.fillStyle = water;
    ctx.fillRect(0, waterTop, w, h-waterTop);

    // Waves + shimmer
    ctx.globalAlpha = 0.9;
    for(let i=0;i<10;i++){
      const yy = waterTop + 18 + i*28 + Math.sin(t*0.8 + i)*6;
      ctx.strokeStyle = "rgba(180,220,255,0.10)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      for(let x=0;x<=w;x+=22){
        const y = yy + Math.sin((x*0.03)+t*1.2+i)*4;
        ctx.lineTo(x,y);
      }
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Fish sprite (vector)
  function drawFish(f){
    const {x,y,s,dir,hue,wiggle} = f;
    ctx.save();
    ctx.translate(x,y);
    ctx.scale(dir,1);
    ctx.rotate(Math.sin(wiggle)*0.06);

    // Body gradient
    const body = ctx.createLinearGradient(-40*s,0, 50*s,0);
    body.addColorStop(0, `hsl(${hue} 75% 55%)`);
    body.addColorStop(1, `hsl(${(hue+40)%360} 80% 45%)`);
    ctx.fillStyle = body;

    ctx.beginPath();
    ctx.moveTo(-46*s, 0);
    ctx.quadraticCurveTo(-18*s, -22*s, 20*s, -14*s);
    ctx.quadraticCurveTo(54*s, 0, 20*s, 14*s);
    ctx.quadraticCurveTo(-18*s, 22*s, -46*s, 0);
    ctx.fill();

    // Tail
    ctx.fillStyle = `hsla(${(hue+30)%360} 85% 55% / 0.95)`;
    ctx.beginPath();
    ctx.moveTo(-46*s, 0);
    ctx.lineTo(-70*s, -18*s);
    ctx.lineTo(-66*s, 0);
    ctx.lineTo(-70*s, 18*s);
    ctx.closePath();
    ctx.fill();

    // Fin
    ctx.fillStyle = "rgba(255,255,255,0.22)";
    ctx.beginPath();
    ctx.moveTo(-6*s, 0);
    ctx.quadraticCurveTo(10*s, -26*s, 26*s, -6*s);
    ctx.quadraticCurveTo(10*s, -6*s, -6*s, 0);
    ctx.fill();

    // Eye
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath(); ctx.arc(30*s,-4*s, 4.5*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "rgba(0,0,0,0.65)";
    ctx.beginPath(); ctx.arc(31*s,-4*s, 2.2*s, 0, Math.PI*2); ctx.fill();

    // Sparkle stripe
    ctx.strokeStyle = "rgba(255,255,255,0.20)";
    ctx.lineWidth = 2*s;
    ctx.beginPath();
    ctx.moveTo(-30*s, -2*s);
    ctx.quadraticCurveTo(6*s, -18*s, 38*s, -6*s);
    ctx.stroke();

    ctx.restore();
  }

  function spawnFish(){
    const {w,h} = state;
    const horizon = h*0.36;
    const y = rand(horizon + 80, h - 120);
    const dir = Math.random()<0.5 ? 1 : -1;
    const x = dir===1 ? -120 : w+120;
    const speed = rand(42, 92);
    state.fishes.push({
      x, y,
      vx: speed*dir,
      s: rand(0.65, 1.15),
      dir,
      hue: Math.floor(rand(160, 320)),
      wiggle: rand(0, 10),
      biteChance: rand(0.012, 0.03)
    });
  }

  function addBubble(x,y){
    state.bubbles.push({
      x, y,
      r: rand(2,6),
      vy: rand(-22,-52),
      vx: rand(-8,8),
      a: rand(0.18,0.32),
      life: rand(0.8, 1.6)
    });
  }

  function addSplash(x,y, power){
    for(let i=0;i<12;i++){
      state.splashes.push({
        x, y,
        vx: rand(-70,70) * power,
        vy: rand(-140,-40) * power,
        life: rand(0.35, 0.7),
        a: rand(0.35,0.7),
        r: rand(2,4)
      });
    }
  }

  function setMsg(text, seconds=1.2){
    state.message = text;
    state.msgT = seconds;
  }

  function resetGame(){
    state.score = 0;
    state.phase = "cast";
    state.caughtFish = null;
    state.meter = 0.5;
    state.meterV = 0;
    state.biteNow = false;
    state.biteTimer = 0;
    state.fishes.length = 0;
    state.bubbles.length = 0;
    state.splashes.length = 0;
    resetRod();
    setMsg("Tap to CAST", 2.0);
  }

  // Input
  function pointerXY(e){
    const r = canvas.getBoundingClientRect();
    return { x: (e.clientX - r.left), y: (e.clientY - r.top) };
  }

  function onDown(e){
    e.preventDefault();
    const p = pointerXY(e);
    state.touching = true;
    state.touchX = p.x; state.touchY = p.y;

    if(state.phase === "cast"){
      state.aiming = true;
      state.castPower = 0;
    } else if(state.phase === "bite"){
      // Tap = start reeling
      state.phase = "reel";
      setMsg("Reel it in!", 1.0);
    } else if(state.phase === "catch"){
      resetGame();
    }
  }

  function onMove(e){
    if(!state.touching) return;
    const p = pointerXY(e);
    state.touchX = p.x; state.touchY = p.y;
  }

  function onUp(e){
    e.preventDefault();
    state.touching = false;

    if(state.phase === "cast" && state.aiming){
      state.aiming = false;
      doCast();
    }
  }

  canvas.addEventListener("pointerdown", onDown, {passive:false});
  canvas.addEventListener("pointermove", onMove, {passive:true});
  canvas.addEventListener("pointerup", onUp, {passive:false});
  canvas.addEventListener("pointercancel", onUp, {passive:false});

  // Casting / physics
  function doCast(){
    const {w,h} = state;
    const horizon = h*0.36;

    // power based on hold duration (stored in castPower)
    const p = clamp(state.castPower, 0, 1);
    const angle = lerp(-Math.PI*0.25, -Math.PI*0.05, 0.55); // slight up-right
    const speed = lerp(520, 980, p);

    state.bobX = state.rodX + 26;
    state.bobY = state.rodY + 10;
    state.bobVX = Math.cos(angle) * speed;
    state.bobVY = Math.sin(angle) * speed;
    state.phase = "wait";
    setMsg("Waiting for a bite...", 1.2);
  }

  function waterYAt(x){
    // slightly wavy water surface line
    const h = state.h;
    const base = h*0.36;
    return base + 6 + Math.sin(state.t*1.1 + x*0.02)*4;
  }

  function tick(now){
    const dt = Math.min(0.033, (now - state.last)/1000);
    state.last = now;
    state.t += dt;

    // spawn fish
    if(state.fishes.length < 6 && Math.random() < 0.04) spawnFish();

    // update fish
    for(let i=state.fishes.length-1;i>=0;i--){
      const f = state.fishes[i];
      f.x += f.vx*dt;
      f.wiggle += dt*4;
      if(f.x < -200 || f.x > state.w+200){
        state.fishes.splice(i,1);
      }
    }

    // bubbles
    for(let i=state.bubbles.length-1;i>=0;i--){
      const b = state.bubbles[i];
      b.x += b.vx*dt;
      b.y += b.vy*dt;
      b.life -= dt;
      if(b.life <= 0) state.bubbles.splice(i,1);
    }

    // splashes
    for(let i=state.splashes.length-1;i>=0;i--){
      const s = state.splashes[i];
      s.vy += 420*dt;
      s.x += s.vx*dt;
      s.y += s.vy*dt;
      s.life -= dt;
      if(s.life <= 0) state.splashes.splice(i,1);
    }

    // message timer
    if(state.msgT > 0) state.msgT -= dt;

    // Aim hold power
    if(state.phase === "cast" && state.aiming){
      state.castPower = clamp(state.castPower + dt*0.75, 0, 1);
    }

    // Bobber physics in wait / bite / reel
    if(state.phase === "wait" || state.phase === "bite" || state.phase === "reel"){
      // gravity
      state.bobVY += 1200*dt;
      state.bobX += state.bobVX*dt;
      state.bobY += state.bobVY*dt;

      // water collision
      const wy = waterYAt(state.bobX);
      if(state.bobY > wy){
        state.bobY = wy;
        state.bobVY *= -0.25;
        state.bobVX *= 0.72;
        if(Math.random()<0.6) addBubble(state.bobX+rand(-6,6), state.bobY+rand(4,10));
      }

      // slight water drag
      state.bobVX *= (1 - dt*0.8);

      // keep in bounds
      state.bobX = clamp(state.bobX, 20, state.w-20);

      // chance for bite when waiting and bobber is settled
      if(state.phase === "wait"){
        const settled = Math.abs(state.bobVY) < 40 && Math.abs(state.bobVX) < 50;
        if(settled){
          // pick a fish near bobber
          for(const f of state.fishes){
            const dx = Math.abs(f.x - state.bobX);
            const dy = Math.abs(f.y - (state.bobY + 90));
            if(dx < 120 && dy < 140 && Math.random() < f.biteChance*dt*60){
              state.phase = "bite";
              state.biteNow = true;
              state.biteTimer = 1.4;
              state.meter = 0.5;
              state.meterTarget = rand(0.25, 0.75);
              setMsg("BITE! Tap to REEL!", 1.3);
              addSplash(state.bobX, state.bobY+6, 1.0);
              break;
            }
          }
        }
      }

      // bite timer
      if(state.phase === "bite"){
        state.biteTimer -= dt;
        if(state.biteTimer <= 0){
          // missed
          state.phase = "cast";
          setMsg("Missed! Tap to CAST", 1.4);
          resetRod();
        }
      }

      // reeling mini-game
      if(state.phase === "reel"){
        // meter target wiggle
        state.meterTarget += Math.sin(state.t*1.7)*0.002;
        // user control: keep dot near target by tapping/holding
        const pull = state.touching ? 1 : 0;
        state.meterV += (pull ? -1.25 : 0.95) * dt;
        state.meterV *= (1 - dt*2.2);
        state.meter = clamp(state.meter + state.meterV, 0.05, 0.95);

        // progress: closer = more progress
        const dist = Math.abs(state.meter - state.meterTarget);
        const good = dist < 0.10;
        if(good){
          // reel bobber in a bit and bubble
          state.bobX = lerp(state.bobX, state.rodX + 70, dt*0.8);
          if(Math.random()<0.3) addBubble(state.bobX+rand(-8,8), state.bobY+rand(4,10));
        } else {
          // fish pulls away slightly
          state.bobX = lerp(state.bobX, state.bobX + Math.sin(state.t*3.2)*10, dt*0.25);
        }

        // win condition: bobber close to rod
        const win = Math.abs(state.bobX - (state.rodX+70)) < 18;
        if(win){
          state.phase = "catch";
          state.score += 1;
          state.best = Math.max(state.best, state.score);
          setMsg("Caught one! Tap to play again", 2.0);
          addSplash(state.bobX, state.bobY+6, 1.2);
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }

  // UI + drawing
  function roundRect(x,y,w,h,r){
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y, x+w,y+h, r);
    ctx.arcTo(x+w,y+h, x,y+h, r);
    ctx.arcTo(x,y+h, x,y, r);
    ctx.arcTo(x,y, x+w,y, r);
    ctx.closePath();
  }

  function drawRodAndBobber(){
    const {rodX,rodY,bobX,bobY} = state;

    // Rod
    ctx.lineWidth = 6;
    ctx.strokeStyle = "rgba(210,190,120,0.95)";
    ctx.beginPath();
    ctx.moveTo(rodX-10, rodY+80);
    ctx.quadraticCurveTo(rodX+10, rodY+30, rodX+90, rodY-20);
    ctx.stroke();

    // Line
    ctx.lineWidth = 2;
    ctx.strokeStyle = "rgba(235,245,255,0.65)";
    ctx.beginPath();
    ctx.moveTo(rodX+84, rodY-18);
    ctx.lineTo(bobX, bobY);
    ctx.stroke();

    // Bobber (cute)
    ctx.save();
    ctx.translate(bobX, bobY);
    // shadow on water
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.beginPath();
    ctx.ellipse(0, 10, 16, 6, 0, 0, Math.PI*2);
    ctx.fill();

    // body
    const g = ctx.createLinearGradient(-10,-16, 10, 18);
    g.addColorStop(0, "#ff5b5b");
    g.addColorStop(1, "#c51f1f");
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(0, 0, 14, 16, 0, 0, Math.PI*2);
    ctx.fill();

    // white top
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.beginPath();
    ctx.ellipse(0, -8, 13, 9, 0, 0, Math.PI*2);
    ctx.fill();

    // highlight
    ctx.fillStyle = "rgba(255,255,255,0.25)";
    ctx.beginPath();
    ctx.ellipse(-5, -2, 4, 10, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawParticles(){
    // bubbles
    for(const b of state.bubbles){
      ctx.globalAlpha = b.a;
      ctx.strokeStyle = "rgba(200,240,255,0.9)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;

    // splashes
    for(const s of state.splashes){
      const a = clamp(s.life / 0.7, 0, 1) * s.a;
      ctx.globalAlpha = a;
      ctx.fillStyle = "rgba(210,245,255,0.9)";
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawHUD(){
    const {w,h,score,best,phase,msgT,message} = state;

    // Score pill
    const pad = 14;
    const x = pad, y = pad + state.insetTop;
    const sw = 180, sh = 42;

    ctx.fillStyle = "rgba(0,0,0,0.35)";
    roundRect(x,y,sw,sh,14); ctx.fill();

    ctx.fillStyle = "rgba(232,238,252,0.95)";
    ctx.font = "700 16px -apple-system, system-ui, Arial";
    ctx.fillText(`Score: ${score}`, x+14, y+26);

    ctx.font = "600 12px -apple-system, system-ui, Arial";
    ctx.fillStyle = "rgba(232,238,252,0.70)";
    ctx.fillText(`Best: ${best}`, x+120, y+26);

    // Hint / message
    if(msgT > 0){
      const text = message;
      ctx.font = "700 16px -apple-system, system-ui, Arial";
      const tw = ctx.measureText(text).width;
      const mw = Math.min(w*0.92, tw + 40);
      const mx = (w - mw)/2;
      const my = h*0.62;

      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(mx,my,mw,52,16); ctx.fill();

      ctx.fillStyle = "rgba(232,238,252,0.95)";
      ctx.fillText(text, mx + (mw - tw)/2, my + 33);
    }

    // Reel meter
    if(phase === "reel"){
      const meterW = Math.min(w*0.86, 340);
      const meterH = 18;
      const mx = (w - meterW)/2;
      const my = h*0.76;

      // bar bg
      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(mx, my, meterW, meterH, 10); ctx.fill();

      // target zone
      const tx = mx + state.meterTarget * meterW;
      ctx.fillStyle = "rgba(120,255,160,0.35)";
      roundRect(tx - 22, my+2, 44, meterH-4, 8); ctx.fill();

      // dot
      const dx = mx + state.meter * meterW;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.beginPath();
      ctx.arc(dx, my + meterH/2, 7, 0, Math.PI*2);
      ctx.fill();

      // small instruction
      ctx.fillStyle = "rgba(232,238,252,0.75)";
      ctx.font = "600 13px -apple-system, system-ui, Arial";
      ctx.fillText("Hold screen to reel smoothly", mx, my - 10);
    }

    // Cast power bar
    if(phase === "cast" && state.aiming){
      const bw = Math.min(w*0.72, 280);
      const bh = 16;
      const bx = (w - bw)/2;
      const by = h*0.84;

      ctx.fillStyle = "rgba(0,0,0,0.45)";
      roundRect(bx,by,bw,bh,10); ctx.fill();

      const pw = bw * state.castPower;
      const grad = ctx.createLinearGradient(bx,0,bx+bw,0);
      grad.addColorStop(0, "rgba(120,220,255,0.85)");
      grad.addColorStop(1, "rgba(255,220,120,0.85)");
      ctx.fillStyle = grad;
      roundRect(bx,by,pw,bh,10); ctx.fill();

      ctx.fillStyle = "rgba(232,238,252,0.75)";
      ctx.font = "600 13px -apple-system, system-ui,
